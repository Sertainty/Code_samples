/* Keycode Generated by Uluro 
   Created 06/20/2014 19:21:02
*/
 
rule NewAppliance::setup() 
{ 
  depends on rule commonSetup(success); 
 
  CredentialType cred; 
  ChallengeType ch; 
  ConfigType config; 
 
  cred.Name = "test";
  cred.TimeLow = 0; 
  cred.TimeHigh = 300; 
  cred.ValidationType = ValidationLocal; 
  cred.Privileges = AccessOwner; 
  cred.Email = "greg.smith@sertintyone.com";
  cred.DataMask = concat(MaskUserData, ",", MaskYear); 
  cred.Schedule.Sunday = true; 
  cred.Schedule.Saturday = true; 
  cred.Schedule.Monday = true; 
  cred.Schedule.Tuesday = true; 
  cred.Schedule.Wednesday = true; 
  cred.Schedule.Thursday = true; 
  cred.Schedule.Friday = true; 
  cred.Schedule.StartHour = -1; 
  cred.Schedule.EndHour = -1; 
  cred.Schedule.StartMinute = -1; 
  cred.Schedule.EndMinute = -1; 
  cred.Schedule.StartDay = 19;
  cred.Schedule.StartMonth = 6;
  cred.Schedule.StartYear =  2014;
  cred.Schedule.EndDay = 20;
  cred.Schedule.EndMonth = 6;
  cred.Schedule.EndYear =  2099;
  defineCredential(cred); 
 
  ch.Name = "USERNAME"; 
  ch.Prompt = "test1";
  ch.Value = "test1";
  ch.TimeLow = 0; 
  ch.TimeHigh = 10; 
  ch.DataType = DataTypeString; 
  ch.SubType = SubTypeUserPhrase; 
  ch.FormatType = FormatTypeNatural; 
  ch.Required = true; 
  defineChallenge(cred,ch); 
 
  ch.Name = "test2";
  ch.Prompt = "test2";
  ch.Value = "test2";
  ch.TimeLow = 0; 
  ch.TimeHigh = 10; 
  ch.DataType = DataTypeString; 
  ch.SubType = SubTypeUserPhrase; 
  ch.FormatType = FormatTypeNatural; 
  ch.Required = true; 
  defineChallenge(cred,ch); 
 
  ch.Name = "test3";
  ch.Prompt = "test3";
  ch.Value = "test3";
  ch.TimeLow = 0; 
  ch.TimeHigh = 10; 
  ch.DataType = DataTypeString; 
  ch.SubType = SubTypeUserPhrase; 
  ch.FormatType = FormatTypeNatural; 
  ch.Required = true; 
  defineChallenge(cred,ch); 
 
  ch.Name = "test4";
  ch.Prompt = "test4";
  ch.Value = "test4";
  ch.TimeLow = 0; 
  ch.TimeHigh = 10; 
  ch.DataType = DataTypeString; 
  ch.SubType = SubTypeUserPhrase; 
  ch.FormatType = FormatTypeNatural; 
  ch.Required = true; 
  defineChallenge(cred,ch); 
}
 
  rule Authentication::userSetup() 
  {  
    depends on rule commonSetup(success); 
  } 
  rule Authentication::main() 
  { 
    String buf; 
    /* These rules execute one time */ 
    depends on rule Authentication::complianceCheck(Success);  
    depends on rule Authentication::scheduleCheck(Success);  
    depends on rule Authentication::locationCheck(Success);  
    /* These rules execute upon entry and return */ 
    on entry Authentication::checkFailures(); 
    on return Authentication::checkFailures();

    /* Find the user credential.  If found, UxpCredential is set.  
    * 
    * The return status will contain one or more status bits set.  For 
    * that reason, we must loop through the bits to determine which  
    *    status conditions must be addressed for the next authentication pass. 
    */ 

    int i, status = validateUser();
    if (status == StatusInvalidUsername) 
    { 
       setAuthorization(StatusChallenged, AccessNone); 
       return;
    }

    addConfiguration();

    for (i = 1; i <= StatusBitMax; i++)  
    {  
       switch (bitTest(status, i)) 
       { 
         case 0: 
           break;

         case StatusInvalidUsername:
           break;

         case StatusAuthorized: 
           addConfiguration(); 
           setAuthorization(StatusAuthorized, UxpCredential.Privileges);
           return;

         case StatusScheduleViolation: 
           logFailure("Protected object access attempted outside of valid time window for this user");
           return; 

         case StatusConfigNotFound:
           addConfiguration();
           break;

         case StatusDeviceFound:
           addConfiguration();
           break;

         case StatusLocationFound:
           addConfiguration();
           break;

         case StatusDeviceLocationFound: 
           addConfiguration();
           break;

          default:
            break;
       }
    }

    setAuthorization(StatusChallenged, AccessNone); 

    return;
  }

  /** 
  * Checks session and total failure counts  
  */ 
  rule Authentication::checkFailures()  
  { 
    if (TotalFailureCount >= 3)  
    { 
      destroy(); 
      logFailure("Protected object shredded due to attack"); 
      return (error);
    } 
    if (SessionFailureCount >= 3) 
    { 
      if ((TotalFailureCount + SessionFailureCount) >= 3) 
      { 
         destroy(); 
         logFailure("Protected object shredded due to attack"); 
         return (error);
      } 
      logFailure("Protected object access rejected due to excessive failures"); 
      return (error);
    } 
    return (noaction); 
  }  
 /** 
 * Rule to check compliance independent of the user 
 */ 
 rule Authentication::complianceCheck() 
 { 
   if (today() >= toDate("06/20/2099 00:00"))
   { 
      destroy(); 
      logFailure("Protected object has expired as of 06/20/2099 and has been shredded.");
      return (error); 
   }
   if (today() < toDate("06/19/2014 00:00"))
   { 
      logFailure("Protected object cannot be opened until 06/19/2014."); 
      return (error); 
   }
 
   return (success); 
 }

   /**
    * Rule to check a schedule independent of the user 
    */ 
    rule Authentication::scheduleCheck() 
    { 
      return (success); 
    }

   /** 
   * Rule to check device/location independent of the user 
   */ 
   rule Authentication::locationCheck() 
   { 
     return (success); 
   } 

   rule Compliance::main()
   { 
     return (success); 
   } 

   rule Authentication::fileAccess()
   { 
    CurrentVirtualFileAccess = AccessUnlimited; 
    return success; 
   } 

  rule commonSetup() 
  {
    IsWorkflow = true;
    EnableDebugging = true;
    MasterKey  = "eKHIgLJgmHLpHj5lq5cOnpLOng3pqa15"; 
    MaximumIdleTime = 300; 
    LocationWebServiceEnabled = false; 
    ExternalChallengeLength = 7; 
    IgnoreCase = true; 
    AuditOptions = AuditFailure;
    AlertOptions = AlertLocation | AlertDevice; 

    EmailReplyTo = "noreply@sertintyone.com";
    EmailServer = "smtp.gmail.com";
    EmailPort = 587;
    EmailSecurity = "TLS";
    EmailAuthentication = true;

    EmailSenderName = "SertintyONE SmartFile";
    EmailUser = "noreply@sertintyone.com";
    EmailPwd = "xxx";

    return(success);
  } 
 
 
procedure logFailure(message) 
{ 
  string buf = concat(message, " : ", toString(today()), " (UTC)\n"); 
  sendEmail("greg.smith@sertintyone.com", "Alert: Protected object access failure", buf);
  setAuthorization(StatusNotAuthorized, AccessNone, message); 
}  
